#!/bin/bash
# {{ ansible_managed }}
#
# MIT License
#
# Copyright (c) 2017, 2018, 2019 Fabrizio Colonna <colofabrix@tin.it>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Skip all for noninteractive shells.
# https://www.gnu.org/software/bash/manual/html_node/Is-this-Shell-Interactive_003f.html
[[ "$-" != *"i"* ]] && return

_get_git_tag() {
    if ! which git > /dev/null 2>&1 ; then
        echo ""
        exit
    fi

    local git_status="$(git status --porcelain --branch 2> /dev/null)"

    local git_branch="$(echo "${git_status}" | head -1 | sed -nre 's/^## ([^\.]+).*/\1/p')"
    if [[ -z "$git_branch" ]] ; then
        echo ""
        exit
    fi

    local git_modified="$(echo "$git_status" | egrep "^( M|M ) " | wc -l)"
    [[ "$git_modified" == "0" ]] && \
        git_modified="" || \
        git_modified="${C_FORE_LIGHT_YELLOW}${git_modified}M "

    local git_added="$(echo "$git_status" | egrep "^( A|A ) " | wc -l)"
    [[ "$git_added" == "0" ]] && \
        git_added="" || \
        git_added="${C_FORE_LIGHT_GREEN}${git_added}A "

    local git_deleted="$(echo "$git_status" | egrep "^( D|D ) " | wc -l)"
    [[ "$git_deleted" == "0" ]] && \
        git_deleted="" || \
        git_deleted="${C_FORE_LIGHT_RED}${git_deleted}D "

    local git_other="$(echo "$git_status" | egrep "^( [RC]|[RC] ) " | wc -l)"
    [[ "$git_other" == "0" ]] && \
        git_other="" || \
        git_other="${C_FORE_WHITE}${git_other}O "

    local git_untracked="$(echo "$git_status" | egrep "^\?\? " | wc -l)"
    [[ "$git_untracked" == "0" ]] && \
        git_untracked="" || \
        git_untracked="${C_FORE_LIGHT_MAGENTA}${git_untracked}? "

    local git_changes="${git_added}${git_deleted}${git_modified}${git_other}${git_untracked}"
    if [[ "$git_changes" != "" ]] ; then
        git_changes=" ($(echo "${git_changes}" | sed -e 's/ \+$//')${C_FORE_DEFAULT})"
    fi

    printf "${C_FORE_LIGHT_CYAN}${git_branch}${C_FORE_DEFAULT}${git_changes}"
}

_set_prompt() {
    local last_command=$?       # Must be the first one here
    local tags=()
    local lines=()
    local oIFS=$IFS; IFS=""

    #
    # Tags
    #

    # Date
    tags+=("$C_FORE_WHITE$(date +"%a %x %X")")

    # Username
    current_user="${USERNAME:-$USER}"

    # Root user
    if [[ $EUID == 0 ]] ; then
        tags+=("${C_FORE_LIGHT_RED}ROOT")
    fi

    # Environment
    local machine_env="$(awk '{print toupper($0)}' <<< $MACHINE_ENV)"
    if [[ "$machine_env" == 'INT' ]] ; then
        tags+=("$C_FORE_LIGHT_YELLOW$machine_env")
    elif [[ "$machine_env" == 'PRD' ]] ; then
        tags+=("$C_FORE_LIGHT_RED$machine_env")
    fi

    # GIT repository
    local git_tag="$(_get_git_tag)"
    if [[ -n "$git_tag" ]] ; then
        tags+=("$git_tag")
    fi

    # Command number
    tags+=("$C_FORE_WHITE\!")

    # Result of last command
    if [[ $last_command != 0 ]] ; then
        tags+=("$C_FORE_LIGHT_RED$last_command")
    fi

    #
    # Lines
    #

    # Building LINE 1
    local line=""
    for tag in "${tags[@]}" ; do
        line="$line$C_FORE_DEFAULT[$tag$C_FORE_DEFAULT]"
    done
    if [[ -n "$line" ]] ; then
        lines+=("$line")
    fi

    # Building LINE 2
    lines+=("$C_FORE_GREEN$current_user@\h$C_FORE_DEFAULT: $C_FORE_BLUE\w$C_FORE_DEFAULT")

    # Building LINE 3
    lines+=("\\$ ")

    #
    # Prompt
    #

    export PS1=""
    for ((i = 0; i < {% raw %}${#lines[@]}{% endraw %}; i++)) ; do
        PS1="$PS1\n${lines[$i]}"
    done

    # Emergency prompt, back to the usual one
    #export PS1="\u@\h: \\$ "

    IFS=$oIFS
}

export PROMPT_COMMAND="_set_prompt"

# vim: ft=sh:ts=4:sw=4
